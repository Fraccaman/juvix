Selected out by the twin Darwinian reapers of language network-effect path-dependence and latency-over-correctness content delivery incentives, secure large-scale long-running digital systems are a virtually nonexistent breed. Cutting corners on security reduces costs up front, but the total costs of insecure systems are higher, borne later and unevenly, often by individuals who end up rendered vulnerable instead of empowered by poorly engineered technology. Although the underlying cryptographic primitives in principle can provide a high degree of individual protection (no government on Earth can likely break secure encryption), the imprecisions and inaccuracies in large-scale systems have caused the economics of privacy & capability to devolve into base power dynamics, where even individuals possessed of relevant domain expertise stand little chance against a nation state, terrorist group, or bounty hunter, and mainstream users stand none at all.

This sorry result is overdetermined & difficult to precisely allocate causal responsibility for, but certainly a substantial contributor is the sheer difficulty and cost of formally verifying complex software systems. Most frequently, security is trial-and-error. At best, models are written and checked separately from the code, an expensive and error-prone process. An approach to security which can be expected to result in a different outcome must be construtive & compositional, so that sets of proofs can be imported & reused along with the libraries which comprise most of modern software, and must unify code & proofs into a single efficient language. The approach must result in standards of succinct proofs which can be embedded by the manufacturers of user-facing software, such as web browsers, operating systems, or cryptocurrency wallets, which tightly constrain the opaque behaviour of complex backend codebases. The approach must reduce the costs of formally verifying software to the point where doing so is the economically rational decision for the majority of security-critical projects.

Smart contracts running on distributed ledgers are an archetypal example of a security-critical application, yet results so far have not been promising [@parity-wallet-postmortem] [@zero-ex-postmortem]. Luckily, the field has not yet been locked into particular technologies whose network effects could not be overcome, and the necessity of verifiable & verified software systems is widely-recognized. A radically different language is necessary: one that treats verifiability as a design problem, not a feature to be tacked on later, that provides succinct, expressive, and composable proofs over complex logic, and that reduces the cost of verification to the point where not doing so for security-critical software will be considered simply irresponsible. Juvix aimes to realize this ideal.
