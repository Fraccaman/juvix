## Overview

Juvix translates the semantics of a term to equivalent semantics for an interaction system, consisting of node types, rewrite
rules, write-forward and read-back algorithms (for translating terms to and from nets, respectively),
where elementary-affine-typed terms are in the general case reduced using the oracle-free variant
of Lamping's optimal reduction algorithm.

Compared with previous interaction net interpreters for the lambda calculus utilising a static set
of node types and fixed rewrite rules, Juvix adds an additional degree of freedom:
the node types and rewrite rules of the interaction system can be generated at compile time and even
dynamically altered at runtime according to patterns of rewrite combinations and desired time-space complexity trade-offs.
Additional type data from the core language, such as exact variable usage counts provided by
the instantiation of quantitative type theory with the natural ring, are available to the interaction
system construction algorithm.

also
- refl (equality) proofs in core language can be used by compiler, e.g. with total supply of a token = constant, for queries on the total supply the constant can be returned; more generally if two expressions are equal the compiler can choose which one to evaluate
- will be more effective if graph representation is persistent, instead of written / read-back each contract call. can be used for both code & data

- Define encoding $\phi (t)$ of term $t$ mapping to net $n$
- Define read-back function $\phi ^{-1}(n)$ mapping net $n$ to a term $t$, where $\phi^{-1}(\phi(t)) = t$ holds
- Define interaction system reduction function $\psi(n)$ mapping nets to nets, where $\phi^{-1}(\psi(\phi(t))) = reduce\ t$ where $reduce$ is as defined in the semantics of Juvix Core

## Interaction system encoding

EAL term language $t ::= x\ |\ λx.t\ |\ (t u)\ |\ !t$.

EAL type $A ::= α\ |\ A\ ⊸\ A\ |\ !A$.

EAL-typed terms can be translated into interaction nets, in accordance with the sequent calculus typing rules, as the function $\phi$ as follows.

The EAL term is first erased to a simply-typed term, with EAL types and levels of subterms retained in a lookup table for reference during the translation.

**Abstraction** is applied to terms of the form $λx.t$ and type $A ⊸ B$.

\begin{tikzpicture}
  \inetbigcell[right = 30pt]{g}{$\phi (t)$}[4]
  \inetbigcell[below = 30pt]{l}{$λ$}[3]

  \axWire{g/1}{l/1}{$(arg)$}{}
  \cutWire{g.out}{l/2}{}{}
  \outwire[]{l.out}{$A ⊸ B$}
\end{tikzpicture}

Wiring of the argument $x$ varies depending on variable usage linearity:

**Weakening**: If $x$ does not appear in the body $t$, the $λ$ argument port is connected to an eraser.

\begin{tikzpicture}
  \inetbigcell[right = 30pt]{g}{$\phi (t)$}[4]
  \inode[]{e}{$⊗$}
  \inetbigcell[below = 30pt]{l}{$λ$}[3]

  \cutWire{e}{l/1}{$$}{}
  \cutWire{g.out}{l/2}{$$}{}
  \outwire[]{l.out}{$A ⊸ B$}
\end{tikzpicture}

**Linear / contraction**: If *x* appears once or more in the body $t$, the $λ$ argument port is connected to the occurrence(s). If there is more than one occurrence, usages will be shared by a set of fan nodes constructed by the application encoding.

\begin{tikzpicture}
  \inetbigcell[right = 30pt]{g}{$\phi (t)$}[4]
  \inetbigcell[below = 30pt]{l}{$λ$}[3]

  \axWire{g/1}{l/1}{}{}
  \cutWire{g.out}{l/2}{}{}
  \outwire[]{l.out}{$A ⊸ B$}
\end{tikzpicture}

**Application** is applied to terms of the form $(t_1 t_2)$ and type $C$.

\begin{tikzpicture}

  \inetbigcell[right = -25 pt]{g}{$\phi(t_1)$}[3]
  \inetbigcell[right = 25 pt]{h}{$\phi(t_2)$}[3]
  \inetbigcell[below = 40 pt]{a}{$@$}[3]

  \cutWire{g.out}{a/1}{}{}
  \cutWire{h.out}{a/2}{}{}
  \outwire[]{a.out}{$C$}

\end{tikzpicture}

For each free variable $x$ in $(t_1 t_2)$ occurring more than once, all occurrences of $x$ must be connected by a tree of fan-in nodes, each with a globally unique label (only one fan-in node is shown in the diagram).

\begin{tikzpicture}

  \inetbigcell[rotate = 180, above = 40 pt]{f}{\rotatebox[origin=c]{180}{$f_i$}}[3]
  \inetbigcell[right = -25 pt]{g}{$\phi(t_1)$}[3]
  \inetbigcell[right = 25 pt]{h}{$\phi(t_2)$}[3]
  \inetbigcell[below = 40 pt]{a}{$@$}[3]

  \cutWire{g.out}{a/1}{}{}
  \cutWire{h.out}{a/2}{}{}
  \outwire[]{a.out}{$C$}
  \inwire[]{f.out}{$x$}

  \axWire{g/1}{f/1}{}{}
  \axWire{h/1}{f/2}{}{}
\end{tikzpicture}

That ends the encoding rules.

Example from chat & paper (of derivation).

## Oracle-free optimal reduction

The oracle-free abstract algorithm for optimal reduction operates on four node types: $λ$ (lambda), $@$ (application), $f_i$ (fan, with index $i$), and $⊗$ (eraser). Rewrite rules always operate only on primary port pairs and consist of two categories: **annihilation** rules, which remove nodes, and **commutation** rules, which create nodes.

\floatstyle{plain}
\restylefloat{figure}

\begin{figure}[H]
  \caption{Lambda-application annihilation (beta reduction)}
  \begin{subfigure}[c]{0.1\textwidth}
    \begin{tikzpicture}
      \inetcell[]{a}{$@$}[5]
      \inetcell[rotate = 180, below = 50 pt]{l}{\rotatebox[origin=c]{180}{$λ$}}[5]
      \inwire[]{a/1}{a}
      \inwire[]{a/4}{d}
      \outwire[]{l/1}{c}
      \outwire[]{l/4}{b}
      \cutWire{a.out}{l.out}{}{}
    \end{tikzpicture}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.05\textwidth}
    \huge{→}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.1\textwidth}
    \begin{tikzpicture}
      \wirecross[]{a}{c}{b}{d}
    \end{tikzpicture}
  \end{subfigure}
\end{figure}

\begin{figure}[H]
  \caption{Fan-fan commutation}
  \begin{subfigure}[c]{0.1\textwidth}
    \begin{tikzpicture}
      \inetcell[]{a}{$f_i$}[5]
      \inetcell[rotate = 180, below = 50 pt]{b}{\rotatebox[origin=c]{180}{$f_j$}}[5]
      \inwire[]{a/1}{a}
      \inwire[]{a/4}{d}
      \outwire[]{b/1}{c}
      \outwire[]{b/4}{b}
      \cutWire{a.out}{b.out}{}{}
    \end{tikzpicture}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.05\textwidth}
    \huge{→}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.1\textwidth}
    \begin{tikzpicture}
      \inetcell[rotate = 180]{a}{\rotatebox[origin=c]{180}{$f_j$}}[5]
      \inetcell[rotate = 180, right = 60 pt of a]{b}{\rotatebox[origin=c]{180}{$f_j$}}[5]
      \inetcell[below = 40 pt of a]{c}{$f_i$}[5]
      \inetcell[below = 40 pt of b]{d}{$f_i$}[5]
      \inwire[]{a.out}{a}
      \inwire[]{b.out}{d}
      \outwire[]{c.out}{b}
      \outwire[]{d.out}{c}
      \swire[0]{a/4}{c/1}{}{}
      \swire[0]{b/1}{d/4}{}{}
      \swire[0]{a/1}{d/1}{}{}
      \swire[0]{b/4}{c/4}{}{}
    \end{tikzpicture}
  \end{subfigure}
\end{figure}

\begin{figure}[H]
  \caption{Fan-application commutation}
  \begin{subfigure}[c]{0.1\textwidth}
    \begin{tikzpicture}
      \inetcell[]{a}{$f_i$}[5]
      \inetcell[rotate = 180, below = 50 pt]{b}{\rotatebox[origin=c]{180}{$@$}}[5]
      \inwire[]{a/1}{a}
      \inwire[]{a/4}{d}
      \outwire[]{b/1}{c}
      \outwire[]{b/4}{b}
      \cutWire{a.out}{b.out}{}{}
    \end{tikzpicture}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.05\textwidth}
    \huge{→}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.1\textwidth}
    \begin{tikzpicture}
      \inetcell[rotate = 180]{a}{\rotatebox[origin=c]{180}{$@$}}[5]
      \inetcell[rotate = 180, right = 60 pt of a]{b}{\rotatebox[origin=c]{180}{$@$}}[5]
      \inetcell[below = 40 pt of a]{c}{$f_i$}[5]
      \inetcell[below = 40 pt of b]{d}{$f_i$}[5]
      \inwire[]{a.out}{a}
      \inwire[]{b.out}{d}
      \outwire[]{c.out}{b}
      \outwire[]{d.out}{c}
      \swire[0]{a/4}{c/1}{}{}
      \swire[0]{b/1}{d/4}{}{}
      \swire[0]{a/1}{d/1}{}{}
      \swire[0]{b/4}{c/4}{}{}
    \end{tikzpicture}
  \end{subfigure}
\end{figure}

\begin{figure}[H]
  \caption{Fan-lambda commutation}
  \begin{subfigure}[c]{0.1\textwidth}
    \begin{tikzpicture}
      \inetcell[]{a}{$f_i$}[5]
      \inetcell[rotate = 180, below = 50 pt]{b}{\rotatebox[origin=c]{180}{$λ$}}[5]
      \inwire[]{a/1}{a}
      \inwire[]{a/4}{d}
      \outwire[]{b/1}{c}
      \outwire[]{b/4}{b}
      \cutWire{a.out}{b.out}{}{}
    \end{tikzpicture}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.05\textwidth}
    \huge{→}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.1\textwidth}
    \begin{tikzpicture}
      \inetcell[rotate = 180]{a}{\rotatebox[origin=c]{180}{$λ$}}[5]
      \inetcell[rotate = 180, right = 60 pt of a]{b}{\rotatebox[origin=c]{180}{$λ$}}[5]
      \inetcell[below = 40 pt of a]{c}{$f_i$}[5]
      \inetcell[below = 40 pt of b]{d}{$f_i$}[5]
      \inwire[]{a.out}{a}
      \inwire[]{b.out}{d}
      \outwire[]{c.out}{b}
      \outwire[]{d.out}{c}
      \swire[0]{a/4}{c/1}{}{}
      \swire[0]{b/1}{d/4}{}{}
      \swire[0]{a/1}{d/1}{}{}
      \swire[0]{b/4}{c/4}{}{}
    \end{tikzpicture}
  \end{subfigure}
\end{figure}

\begin{figure}[H]
  \caption{Fan-fan annihilation}
  \begin{subfigure}[c]{0.1\textwidth}
    \begin{tikzpicture}
      \inetcell[]{a}{$f_i$}[5]
      \inetcell[rotate = 180, below = 50 pt]{b}{\rotatebox[origin=c]{180}{$f_i$}}[5]
      \inwire[]{a/1}{a}
      \inwire[]{a/4}{d}
      \outwire[]{b/1}{c}
      \outwire[]{b/4}{b}
      \cutWire{a.out}{b.out}{}{}
    \end{tikzpicture}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.05\textwidth}
    \huge{→}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.1\textwidth}
    \begin{tikzpicture}
      \wirestraight[]{a}{c}{b}{d}
    \end{tikzpicture}
  \end{subfigure}
\end{figure}

\begin{figure}[H]
  \caption{Eraser-lambda commutation}
  \begin{subfigure}[c]{0.1\textwidth}
    \begin{tikzpicture}
      \inetcell[]{a}{$λ$}[5]
      \inode[below = 40 pt]{b}{$⊗$}
      \inwire[]{a/1}{a}
      \inwire[]{a/4}{d}
      \cutWire{a.out}{b.north}{}{}
    \end{tikzpicture}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.05\textwidth}
    \huge{→}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.1\textwidth}
    \begin{tikzpicture}
      \inode[]{a}{$⊗$}
      \inode[right = 20 pt]{b}{$⊗$}
      \inwire[]{a}{a}
      \inwire[]{b}{d}
    \end{tikzpicture}
  \end{subfigure}
\end{figure}

\begin{figure}[H]
  \caption{Eraser-application commutation}
  \begin{subfigure}[c]{0.1\textwidth}
    \begin{tikzpicture}
      \inetcell[]{a}{$@$}[5]
      \inode[below = 40 pt]{b}{$⊗$}
      \inwire[]{a/1}{a}
      \inwire[]{a/4}{d}
      \cutWire{a.out}{b.north}{}{}
    \end{tikzpicture}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.05\textwidth}
    \huge{→}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.1\textwidth}
    \begin{tikzpicture}
      \inode[]{a}{$⊗$}
      \inode[right = 20 pt]{b}{$⊗$}
      \inwire[]{a}{a}
      \inwire[]{b}{d}
    \end{tikzpicture}
  \end{subfigure}
\end{figure}

\begin{figure}[H]
  \caption{Eraser-fan commutation}
  \begin{subfigure}[c]{0.1\textwidth}
    \begin{tikzpicture}
      \inetcell[]{a}{$f_i$}[5]
      \inode[below = 40 pt]{b}{$⊗$}
      \inwire[]{a/1}{a}
      \inwire[]{a/4}{d}
      \cutWire{a.out}{b.north}{}{}
    \end{tikzpicture}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.05\textwidth}
    \huge{→}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.1\textwidth}
    \begin{tikzpicture}
      \inode[]{a}{$⊗$}
      \inode[right = 20 pt]{b}{$⊗$}
      \inwire[]{a}{a}
      \inwire[]{b}{d}
    \end{tikzpicture}
  \end{subfigure}
\end{figure}

\begin{figure}[H]
  \caption{Eraser-eraser annihilation}
  \begin{subfigure}[c]{0.1\textwidth}
    \begin{tikzpicture}
      \inode[]{a}{$⊗$}
      \inode[below = 40 pt]{b}{$⊗$}
      \vwire{a}{b}
    \end{tikzpicture}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.05\textwidth}
    \huge{→}
  \end{subfigure}
  ~
  \begin{subfigure}[c]{0.1\textwidth}
  \end{subfigure}
\end{figure}

\floatstyle{boxed}
\restylefloat{figure}

### Argument for correctness


## Bespoke term encoding

- Primitive types (integer, string, bytes) ~> node types w/data
- n-arity primitive functions (+, -, *, concat, index) ~> rewrite rules
- alt-term encoding: $\lambda x. x + x + x$ ~> $3 * x$ rewrite rule instead of multi-node graph

- Over set of underlying opcodes & von-Neumann-ish VM (e.g. x86, LLVM, EVM).
- Use linear types (e.g. rewrite memory locations in place)
- Must be semantically equivalent to interaction system encoding after read-back
- Must preserve any-order reduction (exists some maximum `n` rewrite steps after which graph read-back must have final form regardless of order)
- Can relax diamond property (strong confluence)? unclear if necessary

### Argument for Correct read-back

We wish to show that a read-back of an EAL-expression that has undergone zero or more reductions gives back the same result as normal evaluation up to alpha equality.

Before we can prove this result, we must first prove a few lemmas and theorems first as well talk about what fan in's with the same label imply.

The first lemma we wish to prove is the following

\begin{Lemma}{AST→Net has one free port}{AST->Net}
  Let $A$ = be a valid BOHM ADT.
  \\ \\
  Now Consider the net over $A$, let $N_a$ be this net.
  \\ \\
  Now let us consider any sub case of $A$, $L = P(n_1 \star \cdots \star n_k)$.
  \\ \\
  The node corresponding to $L$ looks.

  \begin{tikzpicture}
    \draw (0,0) circle (.8cm);
  \end{tikzpicture}

  Where the labels in $N_a$ are the same as in $L$, with $n_{k+1}$ being an extra port which connects to the ADT above it.
  \\ \\
  For an ADT to be realized, we must have all arguments, so all these ports must be connected.
  Now, if $L$ is $A$, then we have one free port, however if it is not, then this free port must not be free but instead be connected to the ADT above it.
  \\ \\
  $\therefore$ AST→Net has one free port
\end{Lemma}


Now we need to prove that evaluating this net does not change this fact


\begin{Theorem}{AST→Net→Eval has one free port}{AST->Net->Eval}
  Let $A = Net(AST)$.
  \\ \\
  By lemma \ref{Lm:AST->Net} $A$ has one free port.
  \\ \\
  We must now show $Eval(A)$ does not change the number of free ports.
  \\ \\
  We can show this by simply considering how every reduction rule works. For the sake of brevity, we will only consider the three variations of rewrite rules present in the BOHM system WLOG.

  \begin{tcolorbox}[title=Case 1 - Rewire, colframe=inner-box-1]
    \begin{figure}[H]
      \begin{subfigure}[c]{0.1\textwidth}
        \begin{tikzpicture}
          \inetcell[]{a}{$g$}[5]
          \inetcell[rotate = 180, below = 50 pt]{l}{\rotatebox[origin=c]{180}{$f$}}[5]
          \inwire[]{a/1}{a}
          \inwire[]{a/4}{d}
          \outwire[]{l/1}{c}
          \outwire[]{l/4}{b}
          \cutWire{a.out}{l.out}{}{}
        \end{tikzpicture}
      \end{subfigure}
      ~
      \begin{subfigure}[c]{0.05\textwidth}
        \huge{→}
      \end{subfigure}
      ~
      \begin{subfigure}[c]{0.1\textwidth}
        \begin{tikzpicture}
          \wirecross[]{a}{c}{b}{d}
        \end{tikzpicture}
      \end{subfigure}
    \end{figure}

    We can see that there is only one wire eliminated, the one connecting the main ports of node $f$ and node $g$.
    \\ \\
    The rest of the wires are simply rewired to each other, thus not effecting the total number of free ports
  \end{tcolorbox}

  \begin{tcolorbox}[title=Case 2 - Isolation, colframe=inner-box-1]
    \begin{figure}[H]
      \caption{Eraser-application commutation}
      \begin{subfigure}[c]{0.1\textwidth}
        \begin{tikzpicture}
          \inetcell[]{a}{$f$}[6]
          \inode[below = 40 pt]{b}{$g$}
          \inwire[]{a/1}{a}
          \inwire[]{a/3}{b}
          \inwire[]{a/5}{c}
          \cutWire{a.out}{b.north}{}{}
        \end{tikzpicture}
      \end{subfigure}
      ~
      \begin{subfigure}[c]{0.05\textwidth}
        \huge{→}
      \end{subfigure}
      ~
      \begin{subfigure}[c]{0.1\textwidth}
        \begin{tikzpicture}
          \inode[right = 20 pt]{b}{$⊗$}
          \inwire[]{b}{b}
          \draw (-1.5,-1.5) node{a}  .. controls (-1.5,1) and (0,-1.5) .. (0,1) node{c};
        \end{tikzpicture}
      \end{subfigure}
    \end{figure}

    Here we can see that like the first case the wire that connects the main ports are eliminated, and that $a$ and $c$ are rewired.
    \\ \\
    Additionally an eraser node is connected to the $b$, since the eraser node only has a main port, the number of free ports is not affected.
  \end{tcolorbox}

  \begin{tcolorbox}[title=Case 3 - Duplication, colframe=inner-box-1]
    \begin{figure}[H]
      \begin{subfigure}[c]{0.1\textwidth}
        \begin{tikzpicture}
          \inetcell[]{a}{$f_i$}[5]
          \inetcell[rotate = 180, below = 50 pt]{b}{\rotatebox[origin=c]{180}{$a$}}[5]
          \inwire[]{a/1}{a}
          \inwire[]{a/4}{d}
          \outwire[]{b/1}{c}
          \outwire[]{b/4}{b}
          \cutWire{a.out}{b.out}{}{}
        \end{tikzpicture}
      \end{subfigure}
      ~
      \begin{subfigure}[c]{0.05\textwidth}
        \huge{→}
      \end{subfigure}
      ~
      \begin{subfigure}[c]{0.1\textwidth}
        \begin{tikzpicture}
          \inetcell[rotate = 180]{a}{\rotatebox[origin=c]{180}{$a$}}[5]
          \inetcell[rotate = 180, right = 60 pt of a]{b}{\rotatebox[origin=c]{180}{$a$}}[5]
          \inetcell[below = 40 pt of a]{c}{$f_i$}[5]
          \inetcell[below = 40 pt of b]{d}{$f_i$}[5]
          \inwire[]{a.out}{a}
          \inwire[]{b.out}{d}
          \outwire[]{c.out}{b}
          \outwire[]{d.out}{c}
          \swire[0]{a/4}{c/1}{}{}
          \swire[0]{b/1}{d/4}{}{}
          \swire[0]{a/1}{d/1}{}{}
          \swire[0]{b/4}{c/4}{}{}
        \end{tikzpicture}
      \end{subfigure}
    \end{figure}
    Here we see the case for a fan-in node $f_i$ and some arbitrary node $a$. Both nodes get duplicated,
    however the number of free ports is preserved, as each node that is created is internally connected to the duplicated nodes.
    Additionally the four external ports are preserved among the four duplicated nodes.
  \end{tcolorbox}
  $\therefore$ since all cases are covered, $Eval(A)$ has only one free port.
\end{Theorem}

We now shall define one more definition before getting to our main theorem.


\begin{Definition}{Valid EAL-Net}{Valid EAL-Net}
  A \textcolor{definitions}{\textbf{Valid EAL-Net}} is a net translated from the EAL subset subset of BOHM and has undergone zero or more reduction steps.
\end{Definition}

\begin{Theorem}{Read back from a Valid EAL-Net gives is $α$ equivalent to the normal evaluation of the original EAL-term}{readback}
  Let $A$ be the Valid EAL-Net.
\end{Theorem}

## Evaluator cost model

Currently tracked:

- Memory allocations
- Sequential rewrite steps
- Parallel rewrite steps
- Maximum graph size
- Final graph size

In the future we may want to track more granular memory operations (reads/writes in addition to allocations) and computations associated with rewrite rules (all negligible-cost with interaction combinators, but not with e.g. integer arithmetic).

Machine backends are expected to provide a discrete cost model which can be utilised by the optimiser.

## Future optimisation strategies

Juvix does not yet implement these, but the compiler architecture has kept their possibility in mind.

### Spacial memory contiguity

Random access O(1) model is imperfect; sequential reads are faster. Ensure correspondence between graphical locality and spacial locality in memory, read nodes in blocks.

### Speculative execution

- "Strict" optimal reduction strategies
- Evaluate based on predicting future input (feasible?)

### Stochastic superoptimisation

- Utilise sparse sampling (probably Markov-chain Monte Carlo) to search the configuration space of semantically equivalent programs & select the fastest.
- Probably useful at the level of choosing machine implementations of particular rewrite rules.
- See Stochastic Superoptimisation [@stochastic-superoptimization]
- Will need a lot of clever tricks to avoid getting stuck in local minima (that paper details several).
- See also STOKE [@stoke]

### "Superoptimal" reduction strategies

- Specifically those with the possibility of asymptotically-better performance than Levy's optimal reduction.
- As far as I can tell, the only candidates here are forms of memoisation which attempt to detect syntactically identical structures during the reduction process which can then be linked and evaluated only once.
- [Hash consing](https://en.wikipedia.org/wiki/Hash_consing) may have the most prior research.
- Concerns about space-time trade-offs (may already be concerns).
